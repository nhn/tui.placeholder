tui.util.defineNamespace("fedoc.content", {});
fedoc.content["src_util.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>'use strict';\n\nvar callbackPropName = function(eventType) {\n    return '__cb_tui_placeholder_' + eventType + '__';\n};\n\nvar hasComputedStyle = (window.getComputedStyle);\nvar exceptEvents = ['propertychange'];\n\nvar util = {\n    /**\n     * Generate 'style' element and add css rule\n     * @param {Object} ruleInfo - Value of selector and css property\n     */\n    addCssRule: function(ruleInfo) {\n        var styleTag = document.createElement('style');\n        var selector = ruleInfo.selector;\n        var css = ruleInfo.css;\n        var styleSheet;\n\n        if (document.head) {\n            document.head.appendChild(styleTag);\n        } else {\n            document.getElementsByTagName('head')[0].appendChild(styleTag);\n        }\n\n        styleSheet = styleTag.sheet || styleTag.styleSheet;\n\n        if (styleSheet.insertRule) {\n            styleSheet.insertRule(selector + '{' + css + '}', 0);\n        } else {\n            styleSheet.addRule(selector, css, 0);\n        }\n    },\n\n    /**\n     * Bind event to element\n     * @param {HTMLElement} target - DOM element to attach the event handler on\n     * @param {string} eventType - Event type\n     * @param {requestCallback} callback - Event handler function\n     */\n    bindEvent: function(target, eventType, callback) {\n        var success = true;\n\n        if (target.addEventListener &amp;&amp;\n            tui.util.inArray(eventType, exceptEvents) === -1) {\n            target.addEventListener(eventType, callback, false);\n        } else if (target.attachEvent) {\n            target.attachEvent('on' + eventType, callback);\n        } else {\n            success = false;\n        }\n\n        if (success) {\n            target[callbackPropName(eventType)] = callback;\n        }\n    },\n\n    /**\n     * Unbind event from element\n     * @param {HTMLElement} target - DOM element to detach the event handler from\n     * @param {string} eventType - Event type\n     */\n    unbindEvent: function(target, eventType) {\n        var callback = target[callbackPropName(eventType)];\n        var success = true;\n\n        if (target.removeEventListener &amp;&amp;\n            tui.util.inArray(eventType, exceptEvents) === -1) {\n            target.removeEventListener(eventType, callback);\n        } else if (target.detachEvent) {\n            target.detachEvent('on' + eventType, callback);\n        } else {\n            success = false;\n        }\n\n        if (success) {\n            delete target[callbackPropName(eventType)];\n        }\n    },\n\n    /**\n     * Remove target items from source array and returns a new removed array.\n     * @param {array} sourceItems - source array\n     * @param {array} targetItems - target items\n     * @returns {array} new removed array\n     */\n    removeArrayItems: function(sourceItems, targetItems) {\n        return tui.util.filter(sourceItems, function(item) {\n            return tui.util.inArray(item, targetItems) === -1;\n        });\n    },\n\n    /**\n     * Make CSSText\n     * @param {Object} styleObj - Style info object\n     * @returns {string} Connected string of style\n     */\n    makeStyleText: function(styleObj) {\n        var styleStr = '';\n\n        tui.util.forEach(styleObj, function(value, prop) {\n            styleStr += prop + ':' + value + ';';\n        });\n\n        return styleStr;\n    },\n\n    /**\n     * Replace matched property with template\n     * @param {string} template - String of template\n     * @param {Object} propObj - Properties\n     * @returns {string} Replaced template string\n     */\n    applyTemplate: function(template, propObj) {\n        var newTemplate = template.replace(/\\{\\{(\\w*)\\}\\}/g, function(value, prop) {\n            return propObj.hasOwnProperty(prop) ? propObj[prop] : '';\n        });\n\n        return newTemplate;\n    },\n\n    /**\n     * Returns element's style value defined at css file\n     * @param {HTMLElement} target - Current element\n     * @returns {Object} Style object of element\n     */\n    getStyle: function(target) {\n        var computedObj;\n\n        if (hasComputedStyle) {\n            computedObj = window.getComputedStyle(target, '');\n        } else {\n            computedObj = target.currentStyle;\n        }\n\n        return computedObj;\n    },\n\n    // export to be used by unit-test\n    _callbackPropName: callbackPropName\n};\n\nmodule.exports = util;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"